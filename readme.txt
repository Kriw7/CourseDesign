课程设计 1.18开始评审，得在1.17的时候前做完，现在1.14
记录一下遇到的问题
1.dto类转化的时候需要把表关联的信息放入到Dto当中吗？
    先不放了。
2.时间选择插件
    在管理员添加新的考试的时候，需要选择很多时间。
    本次课设使用了jquery-ui当中的datetimepicker插件。
    使用的步骤：
        1.导入jquery-ui和jquery-ui-timepicker的CSS和JS引用
        2.为input-text调用jquery语句 $(对象).datetimepicker();
        3.可在datetimepicker()中添加json参数来修改datetimepicker()的效果
3.jquery设置css属性
    .attr()
    .prop()
    ！！！！！
    $("#checkbox_all").prop("checked",true); 可以将checked属性改为真，但是$("#checkbox_all").attr("checked",true);却不能
    不是很懂这两个的区别！！！！先用着，后面看着改吧。
4.获得json中数据的数量
    Object.keys(XXXX).length;
5.jquery当中的/不是整除....
    Math.ceil()     向上取整
    Math.floor()    向下取整
6.jquery isNaN()检验是否是非数字。
    !isNaN(xxx) 为真表示是数字
7.数据库的varchar255能存储的汉字不是很多....
    textarea如何显示最大字数和显示实时字数，这个很有意思，放假可以去试试，现在就算了。
8.我有一个很酷的想法
    源自于实验五当中的查看大图的思路，就是设置一个div作为蒙版，在点击考试列表中的请求之后，显示出这个蒙版，然后蒙版里面可以选择修改.
    但是现在的技术水平好像实现不了，或者说时间不够了。已经是1.15的晚上了
9.需要完善的地方
    学生报名或者取消报名之后，由于直接使用了window.location.reload()
    所以直接回到了第一页，用户体验差。有空再补。
10.设计上的失败！
    不应该采用ManyToMany注解的。应该把这个单独拎出来作为一个实体类对象。里面可以存放对应的座位表。
    现在遇到的问题是怎么给学生分配教室和座位表。
    可能的思路：就是使用查询的时候限量.
11.限制缺陷
    忘记设置相同时间段内不能有两场考试重复了。
    加吗....加了。遇到能解决的还是尽量解决吧。
12.为了实现分配考场（分配座位就先不做了把能力有限）所执行的步骤
    1.17现在只实现了基础的内容，需要增加对考场的分配。
    首先，得解决考试的状态的动态变化。
            我的思路是在每个显示考试列表的时候，在后端控制器的部分添加一段检测考试状态的代码，如果当前的时间已经超过了考试报名的时间，就修改状态，
        将可报名的"open"改为"close"。
    其次，管理员在浏览考试的时候，可以为处于"close"状态的考试分配教室，分配教室后更改为"show"。
        这一步的具体内容还未想好，但是先做吧。
        偷懒！就把分配原则设置为 一个大教室能包括所有的报考学生。不行。
        果然还是采用checkbox的方式。选中教室。然后提交。
13.多个checkbox传递值，直接用List<XXX>接受数据会报错
    可以用包装类来接受
14.新的问题
    就是分页和checkbox的集合，当分页之后，前面保留的check会丢失。
    应该可以使用一个临时变量存放已经选中的ID，来不及加了。
15.iterator遍历List集合的时候，如果删除了信息，那么下一次iterator.next()就会报错，因为打乱了它遍历的顺序。
    抛出的异常为：java.util.ConcurrentModificationException
16. 现在是2021.4.18晚上。明天可能就要面试了，重新来看看项目。试着用一下synchronized。
   发现的问题：其一，就是用户登陆之后存储的信息，使用的居然是username和name。这样存在着很大的问题，应该使用主键的值id。
             其二，是可以优化的地方。
                一个用户在两个客户端上登陆，然后选择同一个时间段/同一个类型的考试 报名，可能会出现报名重复的问题。
                    同样类似的还有，一个用户在两个客户端上同时退选不同的考试，可能会出现其中一个退选失效的问题。
                一个用户和一个教师对同一场考试进行处理。教师删除了这场考试，但是用户添加了考试报名的信息。教师的操作必须加锁。
   粗略解决了，关于报名上的问题。在Service添加了Synchronized。
   接下来试着解决幽灵报名的问题。（教师删除了某一场考试，而学生报名了这场考试）。
        2021.4.19 昨晚get了锁粒度相关的知识点。现在对Service层添加Synchronized锁意味着，是把Service和Dao层面进行了加锁。这是非常
   重的锁。加锁的对象是系统层面的Service对象和Dao对象。这会导致同一时刻只有一个用户可以对Service和DAO进行操作。影响了其他用户线程的使用。
        现在尝试进行锁粒度的缩小，改为对用户层面的加锁。思路是：创建一个静态类，里面存放着一个HashMap. 里面存放的就是用户的锁。
        每个用户在进行报名操作的时候，都会尝试先对这个HashMap当中的锁进行加锁操作。